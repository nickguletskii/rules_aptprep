"""Package repository rules and helpers for aptprep extension."""

# Template for individual package BUILD file
_PACKAGE_BUILD_TEMPLATE = """\"\"\"Generated by aptprep extension. DO NOT EDIT.\"\"\"

alias(
    name = "data",
    actual = "@{repo_name}__{package_key}//:data",
    visibility = ["//visibility:public"],
)

alias(
    name = "control",
    actual = "@{repo_name}__{package_key}//:control",
    visibility = ["//visibility:public"],
)

filegroup(
    name = "{architecture}",
    srcs = [":data"]{deps},
    visibility = ["//visibility:public"],
)
"""

# Template for root repository BUILD file
_ROOT_BUILD_TEMPLATE = """\"\"\"Generated by aptprep extension for {repo_name}.\"\"\"
"""

def _generate_package_build_file(repo_name, package_info, dependencies_info):
    """Generate BUILD.bazel content for a package directory.

    Args:
        repo_name: Name of the main repository
        package_info: Dict with package information from lockfile
        dependencies_info: Dict mapping dependency keys to their package info

    Returns:
        String content for BUILD.bazel file
    """
    package_name = package_info["name"]
    architecture = package_info["architecture"]
    dependencies = package_info.get("dependencies", [])

    # Generate dependency references using actual package info from lockfile
    dep_refs = []
    for dep_key in dependencies:
        if dep_key in dependencies_info:
            dep_info = dependencies_info[dep_key]
            dep_name = dep_info["name"]
            dep_arch = dep_info["architecture"]
            dep_refs.append('\"@{}//{}:{}\"'.format(repo_name, dep_name, dep_arch))

    deps_str = " + [\\n        " + ",\\n        ".join(dep_refs) + ",\\n    ]" if dep_refs else ""

    # Use the original package key from the lockfile for the repository reference
    package_key = None
    for key, info in dependencies_info.items():
        if (info["name"] == package_name and
            info["architecture"] == architecture):
            package_key = key
            break

    if not package_key:
        fail("Could not find package key for {}:{}".format(package_name, architecture))

    return _PACKAGE_BUILD_TEMPLATE.format(
        repo_name = repo_name,
        package_key = package_key,
        architecture = architecture,
        deps = deps_str,
    )

def _generate_root_build_file(repo_name):
    """Generate root BUILD.bazel file for the main repository.

    Args:
        repo_name: Name of the repository

    Returns:
        String content for root BUILD.bazel
    """
    return _ROOT_BUILD_TEMPLATE.format(repo_name = repo_name)

def _generate_packages_mapping(packages_dict, repo_name):
    """Generate a JSON file that maps package names to repository names.

    For packages with multiple versions/architectures, use the package key
    to ensure uniqueness.

    Args:
        packages_dict: Dict of all packages from lockfile
        repo_name: Base name of the repository

    Returns:
        String content for the packages_mapping.json file
    """
    return json.encode_indent(_build_packages_mapping(packages_dict, repo_name))

def generate_packages_mapping_with_prefix(packages_dict, repo_prefix):
    """Generate a packages mapping dict with a custom repository prefix.

    Args:
        packages_dict: Dict of all packages from lockfile
        repo_prefix: Prefix for repository names

    Returns:
        JSON string of the packages mapping
    """
    return json.encode_indent(_build_packages_mapping(packages_dict, repo_prefix))

def _build_packages_mapping(packages_dict, repo_prefix):
    """Build the packages mapping dictionary.

    Args:
        packages_dict: Dict of all packages from lockfile
        repo_prefix: Prefix for repository names

    Returns:
        Dict mapping package names to repository names
    """

    # Group packages by name to detect duplicates
    packages_by_name = {}
    for package_key, package_info in packages_dict.items():
        package_name = package_info["name"]
        if package_name not in packages_by_name:
            packages_by_name[package_name] = []
        packages_by_name[package_name].append((package_key, package_info))

    # Generate mapping dict
    mapping = {}

    for package_name in sorted(packages_by_name.keys()):
        variants = packages_by_name[package_name]

        if len(variants) == 1:
            # Single variant, use simple mapping to repository name
            package_key = variants[0][0]
            repo_ref = "{}_{}".format(repo_prefix, package_key)
            mapping[package_name] = repo_ref
        else:
            # Multiple variants, create a dict with architecture keys
            arch_mapping = {}
            for package_key, package_info in variants:
                arch = package_info["architecture"]
                repo_ref = "{}_{}".format(repo_prefix, package_key)
                arch_mapping[arch] = repo_ref
            mapping[package_name] = arch_mapping

    return mapping

def _aptprep_repo_impl(repository_ctx):
    """Implementation for individual package repository."""
    repository_ctx.template(
        "BUILD.bazel",
        Label("//aptprep/private:debian_package.BUILD.tpl"),
    )

aptprep_repo = repository_rule(
    implementation = _aptprep_repo_impl,
    attrs = {},
)

def _aptprep_main_repo_impl(repository_ctx):
    """Implementation for main aptprep repository."""
    repo_name = repository_ctx.attr.repo_name
    packages_data = repository_ctx.attr.packages_data

    # Parse packages data (JSON string) using Bazel's json module
    packages = json.decode(packages_data)

    # Track package directories we need to create
    package_dirs = {}

    # Process packages and organize by package name
    for package_info in packages.values():
        package_name = package_info["name"]

        # Track this package - only one architecture per directory in this implementation
        if package_name not in package_dirs:
            package_dirs[package_name] = package_info

        # TODO: Handle multiple versions/architectures per package

    # Create directory structure and BUILD files
    repository_ctx.file("BUILD.bazel", _generate_root_build_file(repo_name))

    # Generate and write the packages mapping file
    mapping_content = _generate_packages_mapping(packages, repo_name)
    repository_ctx.file("packages_mapping.json", mapping_content)

    # Create package directories and BUILD files
    for package_name, package_info in package_dirs.items():
        build_content = _generate_package_build_file(
            repo_name,
            package_info,
            packages,  # Pass all packages for dependency resolution
        )

        repository_ctx.file("{}/BUILD.bazel".format(package_name), build_content)

aptprep_main_repo = repository_rule(
    implementation = _aptprep_main_repo_impl,
    attrs = {
        "repo_name": attr.string(mandatory = True),
        "packages_data": attr.string(mandatory = True),
    },
)

def _aptprep_fake_repo_impl(_repository_ctx):
    pass

aptprep_fake_repo = repository_rule(
    implementation = _aptprep_fake_repo_impl,
    attrs = {
        "repo_name": attr.string(mandatory = True),
    },
)
